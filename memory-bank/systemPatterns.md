# システムパターン

## アーキテクチャ概要

### 全体構造
Kaizenは、Next.jsをベースにしたモダンなウェブアプリケーションとして構築されています。アーキテクチャは以下の主要レイヤーで構成されています：

1. **プレゼンテーション層**
   - React コンポーネント
   - Tailwind CSS によるスタイリング
   - ユーザーインターフェースとインタラクション

2. **アプリケーション層**
   - コンテキスト管理（React Context API）
   - ビジネスロジック
   - 状態管理

3. **データ層**
   - API クライアント
   - データモデル
   - ストレージ管理

4. **外部サービス統合**
   - Claude API（AI機能）
   - その他の外部APIとの連携

### コンポーネント関係図
```
┌─────────────────────────────────────────────────────────┐
│                  プレゼンテーション層                      │
│                                                         │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐      │
│  │  ワークフロー  │  │  チャット    │  │  メモリー    │      │
│  │  コンポーネント │  │  コンポーネント │  │  コンポーネント │      │
│  └─────────────┘  └─────────────┘  └─────────────┘      │
└───────────────────────────┬─────────────────────────────┘
                            │
┌───────────────────────────┼─────────────────────────────┐
│                  アプリケーション層                        │
│                                                         │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐      │
│  │  ワークフロー  │  │  チャット    │  │  メモリー    │      │
│  │  コンテキスト  │  │  コンテキスト │  │  コンテキスト │      │
│  └─────────────┘  └─────────────┘  └─────────────┘      │
└───────────────────────────┬─────────────────────────────┘
                            │
┌───────────────────────────┼─────────────────────────────┐
│                    データ層                              │
│                                                         │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐      │
│  │  ワークフロー  │  │  チャット    │  │  メモリー    │      │
│  │  データモデル  │  │  データモデル │  │  データモデル │      │
│  └─────────────┘  └─────────────┘  └─────────────┘      │
└───────────────────────────┬─────────────────────────────┘
                            │
┌───────────────────────────┼─────────────────────────────┐
│                  外部サービス統合                         │
│                                                         │
│  ┌─────────────────────┐  ┌─────────────────────┐       │
│  │      Claude API     │  │    その他の外部API    │       │
│  └─────────────────────┘  └─────────────────────┘       │
└─────────────────────────────────────────────────────────┘
```

## 設計パターン

### コンテキストベースの状態管理
- **パターン**: React Context APIを使用した状態管理
- **実装**: WorkflowContext, MemoryContextなどのコンテキストプロバイダー
- **利点**: コンポーネント間でのデータ共有、プロップドリリングの回避
- **使用例**: ワークフロー状態の管理、メモリーバンクのデータアクセス

### コンポーネント分割パターン
- **パターン**: 機能ごとの明確な責任分担を持つコンポーネント設計
- **実装**: 
  - コンテナコンポーネント: ロジックと状態を管理
  - プレゼンテーションコンポーネント: UI表示に特化
- **利点**: 再利用性の向上、テスト容易性、関心の分離
- **使用例**: WorkflowEditor, WorkflowBlock, MemoryBankなど

### カスタムフックパターン
- **パターン**: ロジックの再利用のためのReactカスタムフック
- **実装**: src/hooks/ ディレクトリ内のカスタムフック
- **利点**: ロジックの抽象化と再利用、コンポーネントのシンプル化
- **使用例**: API呼び出し、フォーム管理、認証状態など

### サービスレイヤーパターン
- **パターン**: 外部サービスとの通信を抽象化するサービスレイヤー
- **実装**: src/utils/api.ts などのAPIクライアント
- **利点**: 外部依存の分離、テスト容易性、一貫したエラーハンドリング
- **使用例**: Claude APIとの通信、データの永続化

## 主要実装パス

### ワークフロー管理
1. **データモデル定義**
   - ワークフローとブロックの型定義
   - 状態と遷移の定義

2. **状態管理**
   - WorkflowContextによる状態管理
   - ワークフロー操作のアクション定義

3. **UI実装**
   - WorkflowEditorコンポーネント
   - ドラッグ＆ドロップインターフェース
   - ブロック表示と編集

4. **永続化**
   - ワークフローデータの保存と読み込み
   - バージョン管理

### チャットインターフェース
1. **メッセージモデル**
   - メッセージ型の定義
   - 会話履歴の構造

2. **API統合**
   - Claude APIとの通信
   - プロンプト管理と最適化

3. **UI実装**
   - ChatInterfaceコンポーネント
   - メッセージ表示とフォーム

4. **コンテキスト管理**
   - 会話コンテキストの維持
   - メモリーバンクとの連携

### メモリーバンク
1. **データ構造**
   - メモリーエントリの型定義
   - 階層構造と関連性

2. **状態管理**
   - MemoryContextによる状態管理
   - CRUDオペレーション

3. **UI実装**
   - MemoryBankコンポーネント
   - エントリ表示と編集インターフェース

4. **統合**
   - ワークフローとの連携
   - チャットインターフェースとの連携

## データフロー

### ユーザー操作からの状態更新
1. ユーザーがUIで操作を実行
2. イベントハンドラーがアクションをディスパッチ
3. コンテキストプロバイダーが状態を更新
4. 更新された状態がUIに反映

### 外部APIとの通信
1. ユーザーアクションがAPIリクエストをトリガー
2. サービスレイヤーがリクエストを処理
3. レスポンスデータがコンテキストに保存
4. UIが更新されたデータを表示

### データ永続化
1. 状態変更が永続化アクションをトリガー
2. データがローカルストレージまたはサーバーに保存
3. 読み込み時にデータが復元される
4. 復元されたデータがコンテキストに設定

## 拡張性と保守性

### モジュール分割
- 機能ごとの明確なディレクトリ構造
- 関連するコンポーネント、フック、ユーティリティのグループ化
- 依存関係の明示的な管理

### インターフェース設計
- 明確に定義された型とインターフェース
- コンポーネント間の契約としてのprops型
- 外部依存との統合ポイントの抽象化

### テスト戦略
- コンポーネントの単体テスト
- コンテキストとカスタムフックの統合テスト
- エンドツーエンドのユーザーフロー検証

### 将来の拡張性
- プラグイン機構の検討
- 外部サービス統合のための抽象化レイヤー
- スケーラブルなデータモデルと状態管理
